diff --git a/Cargo.lock b/Cargo.lock
index 82f4bcb..7eafa93 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -2941,7 +2941,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "157c5a9d7ea5c2ed2d9fb8f495b64759f7816c7eaea54ba3978f0d63000162e3"
 dependencies = [
  "anyhow",
- "itertools 0.10.5",
+ "itertools 0.13.0",
  "proc-macro2",
  "quote",
  "syn 2.0.96",
@@ -3011,7 +3011,7 @@ dependencies = [
  "once_cell",
  "socket2",
  "tracing",
- "windows-sys 0.52.0",
+ "windows-sys 0.59.0",
 ]
 
 [[package]]
diff --git a/foundry/src/TychoRouter.sol b/foundry/src/TychoRouter.sol
index 7b7d674..ed2ebe3 100644
--- a/foundry/src/TychoRouter.sol
+++ b/foundry/src/TychoRouter.sol
@@ -235,13 +235,15 @@ contract TychoRouter is
 
     /**
      * @dev Entrypoint to add or replace an approved executor contract address
-     * @param target address of the executor contract
+     * @param targets address of the executor contract
      */
-    function setExecutor(address target)
+    function batchSetExecutor(address[] memory targets)
         external
         onlyRole(EXECUTOR_SETTER_ROLE)
     {
-        _setExecutor(target);
+        for (uint256 i = 0; i < targets.length; i++) {
+            _setExecutor(targets[i]);
+        }
     }
 
     /**
diff --git a/foundry/src/executors/UniswapV2Executor.sol b/foundry/src/executors/UniswapV2Executor.sol
index 9f447f1..16bef82 100644
--- a/foundry/src/executors/UniswapV2Executor.sol
+++ b/foundry/src/executors/UniswapV2Executor.sol
@@ -43,7 +43,7 @@ contract UniswapV2Executor is IExecutor {
             bool zeroForOne
         )
     {
-        if (data.length != 61) {
+        if (data.length < 61) {
             revert UniswapV2Executor__InvalidDataLength();
         }
         inToken = IERC20(address(bytes20(data[0:20])));
diff --git a/foundry/test/Constants.sol b/foundry/test/Constants.sol
index 8776c7d..8cad6fb 100644
--- a/foundry/test/Constants.sol
+++ b/foundry/test/Constants.sol
@@ -16,6 +16,7 @@ contract Constants is Test {
 
     // Dummy contracts
     address DUMMY = makeAddr("dummy");
+    address DUMMY2 = makeAddr("dummy2");
     address PAUSER = makeAddr("pauser");
     address UNPAUSER = makeAddr("unpauser");
 
@@ -37,6 +38,8 @@ contract Constants is Test {
      */
     function deployDummyContract() internal {
         bytes memory minimalBytecode = hex"01"; // Single-byte bytecode
-        vm.etch(DUMMY, minimalBytecode); // Deploy minimal bytecode
+        // Deploy minimal bytecode
+        vm.etch(DUMMY, minimalBytecode);
+        vm.etch(DUMMY2, minimalBytecode);
     }
 }
diff --git a/foundry/test/TychoRouter.t.sol b/foundry/test/TychoRouter.t.sol
index d1a82c7..017a594 100644
--- a/foundry/test/TychoRouter.t.sol
+++ b/foundry/test/TychoRouter.t.sol
@@ -20,15 +20,32 @@ contract TychoRouterTest is TychoRouterTestSetup {
     );
 
     function testSetExecutorValidRole() public {
+        // Set single executor
+        address[] memory executors = new address[](1);
+        executors[0] = DUMMY;
         vm.startPrank(EXECUTOR_SETTER);
-        tychoRouter.setExecutor(DUMMY);
+        tychoRouter.batchSetExecutor(executors);
         vm.stopPrank();
         assert(tychoRouter.executors(DUMMY) == true);
     }
 
+    function testSetExecutorMultipleValidRole() public {
+        // Set multiple executors
+        address[] memory executors = new address[](2);
+        executors[0] = DUMMY;
+        executors[1] = DUMMY2;
+        vm.startPrank(EXECUTOR_SETTER);
+        tychoRouter.batchSetExecutor(executors);
+        vm.stopPrank();
+        assert(tychoRouter.executors(DUMMY) == true);
+        assert(tychoRouter.executors(DUMMY2) == true);
+    }
+
     function testRemoveExecutorValidRole() public {
         vm.startPrank(EXECUTOR_SETTER);
-        tychoRouter.setExecutor(DUMMY);
+        address[] memory executors = new address[](1);
+        executors[0] = DUMMY;
+        tychoRouter.batchSetExecutor(executors);
         tychoRouter.removeExecutor(DUMMY);
         vm.stopPrank();
         assert(tychoRouter.executors(DUMMY) == false);
@@ -41,7 +58,9 @@ contract TychoRouterTest is TychoRouterTestSetup {
 
     function testSetExecutorMissingSetterRole() public {
         vm.expectRevert();
-        tychoRouter.setExecutor(DUMMY);
+        address[] memory executors = new address[](1);
+        executors[0] = DUMMY;
+        tychoRouter.batchSetExecutor(executors);
     }
 
     function testSetVerifierValidRole() public {
diff --git a/foundry/test/TychoRouterTestSetup.sol b/foundry/test/TychoRouterTestSetup.sol
index 97b653d..dc5e713 100644
--- a/foundry/test/TychoRouterTestSetup.sol
+++ b/foundry/test/TychoRouterTestSetup.sol
@@ -56,7 +56,9 @@ contract TychoRouterTestSetup is Test, Constants {
 
         usv2Executor = new UniswapV2Executor();
         vm.startPrank(EXECUTOR_SETTER);
-        tychoRouter.setExecutor(address(usv2Executor));
+        address[] memory executors = new address[](1);
+        executors[0] = address(usv2Executor);
+        tychoRouter.batchSetExecutor(executors);
         vm.stopPrank();
 
         vm.startPrank(BOB);
diff --git a/foundry/test/executors/UniswapV2Executor.t.sol b/foundry/test/executors/UniswapV2Executor.t.sol
index cdc0c89..4f82d24 100644
--- a/foundry/test/executors/UniswapV2Executor.t.sol
+++ b/foundry/test/executors/UniswapV2Executor.t.sol
@@ -93,4 +93,31 @@ contract UniswapV2ExecutorTest is UniswapV2ExecutorExposed, Test, Constants {
         uint256 finalBalance = DAI.balanceOf(BOB);
         assertGe(finalBalance, amountOut);
     }
+
+    function testSwapExecutorEncoderData() public {
+        // Generated by the ExecutorStrategyEncoder - test_executor_encoder
+        bytes memory protocolData =
+            hex"c02aaa39b223fe8d0a0e5c4f27ead9083c756cc288e6a0c2ddd26feeb64f039a2c41296fcb3f564000000000000000000000000000000000000000010000";
+
+        (IERC20 tokenIn, address target, address receiver, bool zeroForOne) =
+            uniswapV2Exposed.decodeParams(protocolData);
+
+        assertEq(address(tokenIn), WETH_ADDR);
+        assertEq(target, 0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640);
+        assertEq(receiver, 0x0000000000000000000000000000000000000001);
+        assertEq(zeroForOne, false);
+    }
+
+    function testSwapExecutorSwap() public {
+        // Generated by the ExecutorStrategyEncoder - test_executor_encoder
+        bytes memory protocolData =
+            hex"c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2a478c2975ab1ea89e8196811f51a7b7ade33eb111d96f2f6bef1202e4ce1ff6dad0c2cb002861d3e0000";
+        uint256 amountIn = 10 ** 18;
+        uint256 amountOut = 1847751195973566072891;
+        deal(WETH_ADDR, address(uniswapV2Exposed), amountIn);
+        uniswapV2Exposed.swap(amountIn, protocolData);
+
+        uint256 finalBalance = DAI.balanceOf(BOB);
+        assertGe(finalBalance, amountOut);
+    }
 }
diff --git a/src/encoding/evm/router_encoder.rs b/src/encoding/evm/router_encoder.rs
index 53ab437..a564e3e 100644
--- a/src/encoding/evm/router_encoder.rs
+++ b/src/encoding/evm/router_encoder.rs
@@ -30,7 +30,7 @@ impl<S: StrategySelector, A: UserApprovalsManager> RouterEncoder<S, A> for EVMRo
         &self,
         solutions: Vec<Solution>,
     ) -> Result<Vec<Transaction>, EncodingError> {
-        let _approvals_calldata = self.handle_approvals(&solutions)?; // TODO: where should we append this?
+        let _approvals_calldata = self.handle_approvals(&solutions)?;
         let mut transactions: Vec<Transaction> = Vec::new();
         for solution in solutions.iter() {
             let exact_out = solution.exact_out;
@@ -39,7 +39,8 @@ impl<S: StrategySelector, A: UserApprovalsManager> RouterEncoder<S, A> for EVMRo
             let strategy = self
                 .strategy_selector
                 .select_strategy(solution);
-            let method_calldata = strategy.encode_strategy((*solution).clone())?;
+            let (method_calldata, target_address) =
+                strategy.encode_strategy((*solution).clone())?;
 
             let contract_interaction = if straight_to_pool {
                 method_calldata
@@ -52,7 +53,11 @@ impl<S: StrategySelector, A: UserApprovalsManager> RouterEncoder<S, A> for EVMRo
             } else {
                 BigUint::ZERO
             };
-            transactions.push(Transaction { value, data: contract_interaction });
+            transactions.push(Transaction {
+                value,
+                data: contract_interaction,
+                to: target_address,
+            });
         }
         Ok(transactions)
     }
diff --git a/src/encoding/evm/strategy_encoder/encoder.rs b/src/encoding/evm/strategy_encoder/encoder.rs
index 7068608..f7fe0f4 100644
--- a/src/encoding/evm/strategy_encoder/encoder.rs
+++ b/src/encoding/evm/strategy_encoder/encoder.rs
@@ -1,5 +1,8 @@
+use std::str::FromStr;
+
 use alloy_primitives::Address;
 use alloy_sol_types::SolValue;
+use tycho_core::Bytes;
 
 use crate::encoding::{
     errors::EncodingError,
@@ -27,7 +30,7 @@ pub trait EVMStrategyEncoder: StrategyEncoder {
 pub struct SplitSwapStrategyEncoder {}
 impl EVMStrategyEncoder for SplitSwapStrategyEncoder {}
 impl StrategyEncoder for SplitSwapStrategyEncoder {
-    fn encode_strategy(&self, _solution: Solution) -> Result<Vec<u8>, EncodingError> {
+    fn encode_strategy(&self, _solution: Solution) -> Result<(Vec<u8>, Bytes), EncodingError> {
         todo!()
     }
     fn selector(&self, _exact_out: bool) -> &str {
@@ -37,10 +40,10 @@ impl StrategyEncoder for SplitSwapStrategyEncoder {
 
 /// This strategy encoder is used for solutions that are sent directly to the pool.
 /// Only 1 solution with 1 swap is supported.
-pub struct StraightToPoolStrategyEncoder {}
-impl EVMStrategyEncoder for StraightToPoolStrategyEncoder {}
-impl StrategyEncoder for StraightToPoolStrategyEncoder {
-    fn encode_strategy(&self, solution: Solution) -> Result<Vec<u8>, EncodingError> {
+pub struct ExecutorStrategyEncoder {}
+impl EVMStrategyEncoder for ExecutorStrategyEncoder {}
+impl StrategyEncoder for ExecutorStrategyEncoder {
+    fn encode_strategy(&self, solution: Solution) -> Result<(Vec<u8>, Bytes), EncodingError> {
         if solution.router_address.is_none() {
             return Err(EncodingError::InvalidInput(
                 "Router address is required for straight to pool solutions".to_string(),
@@ -68,10 +71,87 @@ impl StrategyEncoder for StraightToPoolStrategyEncoder {
             router_address,
         };
         let protocol_data = swap_encoder.encode_swap(swap.clone(), encoding_context)?;
-        // TODO: here we need to pass also the address of the executor to be used
-        Ok(protocol_data)
+        let executor_address = Bytes::from_str(swap_encoder.executor_address())
+            .map_err(|_| EncodingError::FatalError("Invalid executor address".to_string()))?;
+        Ok((protocol_data, executor_address))
     }
     fn selector(&self, _exact_out: bool) -> &str {
-        unimplemented!();
+        "swap(uint256, bytes)"
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use alloy::hex::encode;
+    use num_bigint::BigUint;
+    use tycho_core::{dto::ProtocolComponent, Bytes};
+
+    use super::*;
+    use crate::encoding::models::Swap;
+
+    #[test]
+    fn test_executor_encoder() {
+        let encoder = ExecutorStrategyEncoder {};
+
+        let token_in = Bytes::from("0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2");
+        let token_out = Bytes::from("0x6b175474e89094c44da98b954eedeac495271d0f");
+
+        let swap = Swap {
+            component: ProtocolComponent {
+                id: "0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11".to_string(),
+                protocol_system: "uniswap_v2".to_string(),
+                ..Default::default()
+            },
+            token_in: token_in.clone(),
+            token_out: token_out.clone(),
+            split: 0f64,
+        };
+
+        let solution = Solution {
+            exact_out: false,
+            given_token: token_in,
+            given_amount: BigUint::from(1000000000000000000u64),
+            expected_amount: BigUint::from(1000000000000000000u64),
+            checked_token: token_out,
+            check_amount: None,
+            sender: Bytes::from_str("0x0000000000000000000000000000000000000000").unwrap(),
+            // The receiver was generated with `makeAddr("bob") using forge`
+            receiver: Bytes::from_str("0x1d96f2f6bef1202e4ce1ff6dad0c2cb002861d3e").unwrap(),
+            swaps: vec![swap],
+            straight_to_pool: true,
+            router_address: Some(Bytes::zero(20)),
+            slippage: None,
+            native_action: None,
+        };
+
+        let (protocol_data, executor_address) = encoder
+            .encode_strategy(solution)
+            .unwrap();
+        let hex_protocol_data = encode(&protocol_data);
+        assert_eq!(
+            executor_address,
+            Bytes::from_str("0x5c2f5a71f67c01775180adc06909288b4c329308").unwrap()
+        );
+        assert_eq!(
+            hex_protocol_data,
+            String::from(concat!(
+                // in token
+                "c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
+                // component id
+                "a478c2975ab1ea89e8196811f51a7b7ade33eb11",
+                // receiver
+                "1d96f2f6bef1202e4ce1ff6dad0c2cb002861d3e",
+                // zero for one
+                "00",
+                // exact out
+                "00",
+            ))
+        );
+    }
+
+    #[test]
+    fn test_selector() {
+        let encoder = ExecutorStrategyEncoder {};
+        assert_eq!(encoder.selector(false), "swap(uint256, bytes)");
     }
 }
diff --git a/src/encoding/evm/strategy_encoder/selector.rs b/src/encoding/evm/strategy_encoder/selector.rs
index 37e397c..74cbabd 100644
--- a/src/encoding/evm/strategy_encoder/selector.rs
+++ b/src/encoding/evm/strategy_encoder/selector.rs
@@ -1,5 +1,5 @@
 use crate::encoding::{
-    evm::strategy_encoder::encoder::{SplitSwapStrategyEncoder, StraightToPoolStrategyEncoder},
+    evm::strategy_encoder::encoder::{ExecutorStrategyEncoder, SplitSwapStrategyEncoder},
     models::Solution,
     strategy_encoder::{StrategyEncoder, StrategySelector},
 };
@@ -9,7 +9,7 @@ pub struct EVMStrategySelector;
 impl StrategySelector for EVMStrategySelector {
     fn select_strategy(&self, solution: &Solution) -> Box<dyn StrategyEncoder> {
         if solution.straight_to_pool {
-            Box::new(StraightToPoolStrategyEncoder {})
+            Box::new(ExecutorStrategyEncoder {})
         } else {
             Box::new(SplitSwapStrategyEncoder {})
         }
diff --git a/src/encoding/models.rs b/src/encoding/models.rs
index 4e2cbbd..a31ecaa 100644
--- a/src/encoding/models.rs
+++ b/src/encoding/models.rs
@@ -11,7 +11,7 @@ pub struct Solution {
     /// Amount of the given token.
     pub given_amount: BigUint,
     /// The token being bought (exact in) or sold (exact out).
-    checked_token: Bytes,
+    pub checked_token: Bytes,
     /// Expected amount of the bought token (exact in) or sold token (exact out).
     pub expected_amount: BigUint,
     /// Minimum amount to be checked for the solution to be valid.
@@ -60,6 +60,8 @@ pub struct Transaction {
     pub data: Vec<u8>,
     // ETH value to be sent with the transaction.
     pub value: BigUint,
+    // Address of the contract to call with the calldata
+    pub to: Bytes,
 }
 
 #[allow(dead_code)]
diff --git a/src/encoding/strategy_encoder.rs b/src/encoding/strategy_encoder.rs
index 2b4e348..fd2e757 100644
--- a/src/encoding/strategy_encoder.rs
+++ b/src/encoding/strategy_encoder.rs
@@ -1,8 +1,10 @@
+use tycho_core::Bytes;
+
 use crate::encoding::{errors::EncodingError, models::Solution};
 
 #[allow(dead_code)]
 pub trait StrategyEncoder {
-    fn encode_strategy(&self, to_encode: Solution) -> Result<Vec<u8>, EncodingError>;
+    fn encode_strategy(&self, to_encode: Solution) -> Result<(Vec<u8>, Bytes), EncodingError>;
     fn selector(&self, exact_out: bool) -> &str;
 }
 
